//setting up initial values
let tileMap = [] // creates array for the instances of the Tile class to be added to (two dimensional array)
let tilesX = 32 // how many tiles there are horizontally that make up each level screen
let tilesY = 16 // how many tiles there are vertically that make up each level screen
let tileSize = 50 // height and width of each tile
let hudSize = 100 // height of top bar on screen, showing player health
let textures = [] // creates array for the different tile textures/images to be loaded into
let player1 // used as the instance of the Player class

// where player spawns and respawns at start of game vv (before finding anywhere different to respawn from like a village)
let spawnLevel = 0
let spawnTileX = 26
let spawnTileY = 10

// counter variables, used for anything that will happen after a certain number of loops/frames
let counter = 0 // used for the delay between swapping walking sprites while player is moving
let counter1 = 0 // used for a time of invincibility after the player is hit
let counter2 = 0 // used  for the alpha value for the blackness of the screen increasing when the player dies


let tileIsCollidable = false
let collidableTiles_NotCollidedWith = 0 // count of how many collidable tiles there are that the player hasn't collided with on the map
let collidableTiles = 0 // count of how many collidable tiles there are on the map
let collidableTilesList = [1,80,81,82,83,84,85]

// ensures this.directionState and this.DirectionOfCollision can only be one of four directions at one time. 
// vv
let up = 0
let left = 1
let down = 2
let right = 3

let attackRange = 25


//Slime info
let redSlime;
let redSlimeSprite;
let redSlimeXpos = 50;
let tileY_enemy = 100;
let enemyHp = 10;

//unique NPC variables
let healerDialogue = 1

//NPC dialogues
let dialogue = [
  [// questgiverNPC (dialogue 0)
    "Traveller, please help our people!",
    "The slimes have infested a nearby cave!",
    "Our townspeople usually mine its resources,",
    "and sell them to pay for our imports.",
    "But now it's too dangerous.",
    "Without access to that cave, we'll soon starve!",
    "It's entrance is just to the South of our town, Ravenwind.",
    "Please Traveller, save us!",
    "" // delay to indicate end of what npc has to say
  ],
  [// healerNPC (dialogue 1) // healing damaged player
    "Let's get you patched up, Traveller.",
    "Be careful out there...",
    ""
  ],
  [// healerNPC (dialogue 2) // healing dead player
    "You're lucky someone found you out there Traveller...",
    "Don't get yourself killed.",
    ""
  ],
  [// Back Right house resident (dialogue 3)
    "Something's off with the castle walls behind my house...",
    "Eh, I'm sure it's nothing.",
    ""
  ],
  [// Guards (dialogue 4)
    "Welcome to Ravenwind",
    ""
  ],
  [// Kid (dialogue 5)
    "I'm gonna be a Ravenwind guard one day!",
    "Just you wait!",
    ""
  ],
];

//TILE MAPS

// TILE RULES:
// 0 = Walkable.
// 1 = Collision tile.
// 10 and onwards = Level changer. Sometimes includes a tile topper like a ladder.
// 80 and onwards = NPC. NPCs are also collision tiles.

let level0 = {

  graphicMap: [
  //    THESE ARE OUR Y VALUES
  // 0  1  2  3  4  5  6  7  8  9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31
    [1, 1, 1, 1, 1, 1, 1, 0, 3, 3, 3, 3, 3, 3, 3, 0, 0, 0, 3, 3, 3, 3, 3, 3, 3, 1, 1, 1, 1, 1, 1, 1], // 0
    [1, 1, 1, 1, 1, 1, 1, 0, 3, 3, 3, 3, 3, 3, 3, 0, 0, 0, 3, 3, 3, 3, 3, 3, 3, 1, 1, 1, 1, 1, 1, 1], // 1
    [1, 1, 1, 1, 1, 1, 1, 0, 0, 3, 3, 3, 3, 3, 0, 0, 0, 0, 0, 3, 3, 3, 3, 3, 0, 1, 1, 1, 1, 1, 1, 1], // 2
    [1, 1, 1, 1, 1, 1, 1, 0, 0, 3, 3, 3, 3, 3, 0, 0, 0, 0, 0, 3, 3, 3, 3, 3, 0, 1, 1, 1, 1, 1, 1, 1], // 3
    [1, 1, 1, 1, 1, 1, 1, 1, 0, 3, 3, 3, 3, 3, 0, 0, 0, 0, 0, 3, 3, 3, 3, 3, 0, 1, 1, 1, 1, 1, 1, 1], // 4
    [1, 1, 1, 1, 1, 1, 1, 1, 0, 0, 0, 0, 0, 0, 0, 2, 2, 2, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 1, 1, 1], // 5   THESE ARE OUR X VALUES
    [1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 2, 2, 2, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1], // 6
    [1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 2, 2, 2, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1], // 7
    [1, 1, 1, 1, 1, 1, 1, 0, 0, 0, 0, 0, 1, 1, 0, 2, 2, 2, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 1, 1], // 8
    [1, 1, 1, 1, 1, 1, 0, 0, 0, 0, 0, 0, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 1], // 9
    [1, 1, 1, 1, 1, 1, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 1], // 10
    [1, 1, 1, 1, 1, 1, 0, 0, 0, 0, 0, 0, 2, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 1], // 11
    [1, 1, 1, 1, 1, 1, 1, 0, 0, 0, 0, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 1, 1], // 12
    [1, 1, 1, 1, 1, 1, 1, 0, 0, 0, 0, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 1, 1], // 13
    [1, 1, 1, 1, 1, 1, 1, 1, 1, 0, 1, 1, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 1, 1, 1], // 14
    [1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1]  // 15
  ],

  tileRules: [
  //    THESE ARE OUR Y VALUES
  // 0  1  2  3  4  5  6  7  8  9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31
    [1, 1, 1, 1, 1, 1, 1,13, 1, 1, 1, 1, 1, 1, 1,11,11,11, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1], // 0
    [1, 1, 1, 1, 1, 1, 1, 0, 1, 1, 1, 1, 1, 1, 1, 0, 0, 0, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1], // 1
    [1, 1, 1, 1, 1, 1, 1, 0, 0, 1, 1, 1, 1, 1,83, 0, 0, 0,84, 1, 1, 1, 1, 1, 0, 1, 1, 1, 1, 1, 1, 1], // 2
    [1, 1, 1, 1, 1, 1, 1, 0, 0, 1, 1, 1, 1, 1, 0, 0, 0, 0, 0, 1, 1, 1, 1, 1, 0, 1, 1, 1, 1, 1, 1, 1], // 3
    [1, 1, 1, 1, 1, 1, 1, 1, 0, 1, 1, 1, 1, 1, 0, 0, 0, 0, 0, 1, 1, 1, 1, 1, 0, 1, 1, 1, 1, 1, 1, 1], // 4
    [1, 1, 1, 1, 1, 1, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 1, 1, 1], // 5   THESE ARE OUR X VALUES
    [1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0, 0, 0, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1], // 6
    [1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0, 0, 0, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1], // 7
    [1, 1, 1, 1, 1, 1, 1, 0, 0, 0, 0, 0, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 1, 1], // 8
    [1, 1, 1, 1, 1, 1, 0, 0, 0, 0, 0, 0, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 1], // 9
    [1, 1, 1, 1, 1, 1, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 1], // 10
    [1, 1, 1, 1, 1, 1, 0, 0,22, 0, 0, 0, 2, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 1], // 11
    [1, 1, 1, 1, 1, 1, 1, 0, 0, 0, 0, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 1, 1], // 12
    [1, 1, 1, 1, 1, 1, 1, 0, 0, 0, 0, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 1, 1], // 13
    [1, 1, 1, 1, 1, 1, 1, 1, 1, 0, 1, 1, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 1, 1, 1], // 14
    [1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1]  // 15
    ],

    startTileX : spawnTileX,
    startTileY : spawnTileY
}

let level1 = {

  graphicMap: [
  //    THESE ARE OUR Y VALUES
  // 0  1  2  3  4  5  6  7  8  9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31
    [6, 6, 6, 6, 6, 6, 6, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 6, 6, 6, 6, 6, 6, 6], // 0
    [6, 6, 6, 6, 6, 6, 6, 3, 3, 6, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 6, 6, 6, 6, 6, 6, 6], // 1
    [6, 6, 6, 6, 6, 6, 6, 3, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 3, 6, 6, 6, 6, 6, 6, 6], // 2
    [6, 6, 6, 6, 6, 6, 6, 3, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 2, 2, 2, 3, 6, 6, 6, 6, 6, 6, 6], // 3
    [6, 6, 6, 6, 6, 6, 6, 3, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 2, 6, 2, 3, 6, 6, 6, 6, 6, 6, 6], // 4
    [6, 6, 6, 6, 6, 6, 6, 3, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 3, 6, 6, 6, 6, 6, 6, 6], // 5   THESE ARE OUR X VALUES
    [6, 6, 6, 6, 6, 6, 6, 3, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 3, 6, 6, 6, 6, 6, 6, 6], // 6
    [6, 6, 6, 6, 6, 6, 6, 3, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 3, 6, 6, 6, 6, 6, 6, 6], // 7
    [6, 6, 6, 6, 6, 6, 6, 3, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 3, 6, 6, 6, 6, 6, 6, 6], // 8
    [6, 6, 6, 6, 6, 6, 6, 3, 0, 0, 0, 2, 2, 2, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 3, 6, 6, 6, 6, 6, 6, 6], // 9
    [6, 6, 6, 6, 6, 6, 6, 3, 3, 0, 0, 2, 6, 2, 0, 0, 0, 0, 0, 0, 0, 0, 0, 3, 3, 6, 6, 6, 6, 6, 6, 6], // 10
    [6, 6, 6, 6, 6, 6, 6, 6, 3, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 3, 6, 6, 6, 6, 6, 6, 6, 6], // 11
    [6, 6, 6, 6, 6, 6, 6, 6, 3, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 3, 6, 6, 6, 6, 6, 6, 6, 6], // 12
    [6, 6, 6, 6, 6, 6, 6, 6, 3, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 3, 6, 6, 6, 6, 6, 6, 6, 6], // 13
    [6, 6, 6, 6, 6, 6, 6, 6, 3, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 3, 6, 6, 6, 6, 6, 6, 6, 6], // 14
    [6, 6, 6, 6, 6, 6, 6, 6, 3, 3, 3, 3, 3, 3, 3, 0, 0, 0, 3, 3, 3, 3, 3, 3, 6, 6, 6, 6, 6, 6, 6, 6]  // 15
  ],

  tileRules: [
  //    THESE ARE OUR Y VALUES
  // 0  1  2  3  4  5  6  7  8  9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31
    [1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1], // 0
    [1, 1, 1, 1, 1, 1, 1, 1, 1,14, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,18, 1, 1, 1, 1, 1, 1, 1, 1], // 1
    [1, 1, 1, 1, 1, 1, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 1, 1, 1, 1], // 2
    [1, 1, 1, 1, 1, 1, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1], // 3
    [1, 1, 1, 1, 1, 1, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1,20, 1, 1, 1, 1, 1, 1, 1, 1, 1], // 4
    [1, 1, 1, 1, 1, 1, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 1, 1, 1, 1], // 5   THESE ARE OUR X VALUES
    [1, 1, 1, 1, 1, 1, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 1, 1, 1, 1], // 6
    [1, 1, 1, 1, 1, 1, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 1, 1, 1, 1], // 7
    [1, 1, 1, 1, 1, 1, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 1, 1, 1, 1], // 8
    [1, 1, 1, 1, 1, 1, 1, 1, 0, 0, 0, 1, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 1, 1, 1, 1], // 9
    [1, 1, 1, 1, 1, 1, 1, 1, 1, 0, 0, 1,16, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 1, 1, 1, 1, 1], // 10
    [1, 1, 1, 1, 1, 1, 1, 0, 1, 0, 0, 0, 0, 0, 0, 0,80, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 1, 1, 1, 1, 1], // 11
    [1, 1, 1, 1, 1, 1, 1, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 1, 1, 1, 1, 1], // 12
    [1, 1, 1, 1, 1, 1, 1, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,85, 0, 0, 1, 1, 1, 1, 1, 1, 1, 1, 1], // 13
    [1, 1, 1, 1, 1, 1, 1, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 1, 1, 1, 1, 1], // 14
    [1, 1, 1, 1, 1, 1, 1, 0, 1, 1, 1, 1, 1, 1, 1,10,10,10, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1]  // 15
  ],

  startTileX : 0,
  startTileY : 0
}

let level2 = {

  graphicMap: [
  //    THESE ARE OUR Y VALUES
  // 0  1  2  3  4  5  6  7  8  9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31
    [1, 1, 1, 1, 1, 1, 1, 3, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6], // 0
    [1, 1, 1, 1, 1, 1, 1, 3, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6], // 1
    [1, 1, 1, 1, 1, 1, 1, 3, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6], // 2
    [1, 1, 1, 1, 1, 1, 1, 3, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6], // 3
    [1, 1, 1, 1, 1, 1, 1, 3, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6], // 4
    [1, 1, 1, 1, 1, 1, 1, 3, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6], // 5   THESE ARE OUR X VALUES
    [1, 1, 1, 1, 1, 1, 1, 3, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6], // 6
    [1, 1, 1, 1, 1, 1, 1, 3, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6], // 7
    [1, 1, 1, 1, 1, 1, 1, 3, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6], // 8
    [1, 1, 1, 1, 1, 1, 1, 3, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6], // 9
    [1, 1, 1, 1, 1, 1, 1, 3, 3, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6], // 10
    [1, 1, 1, 1, 1, 1, 1, 0, 3, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6], // 11
    [1, 1, 1, 1, 1, 1, 1, 0, 3, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6], // 12
    [1, 1, 1, 1, 1, 1, 1, 0, 3, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6], // 13
    [1, 1, 1, 1, 1, 1, 1, 0, 3, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6], // 14
    [1, 1, 1, 1, 1, 1, 1, 0, 3, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6]  // 15
  ],

  tileRules: [
  //    THESE ARE OUR Y VALUES
  // 0  1  2  3  4  5  6  7  8  9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31
    [1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1], // 0
    [1, 1, 1, 1, 1, 1, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 1, 1, 1, 1], // 1
    [1, 1, 1, 1, 1, 1, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 1, 1, 1, 1], // 2
    [1, 1, 1, 1, 1, 1, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 1, 1, 1, 1], // 3
    [1, 1, 1, 1, 1, 1, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 1, 1, 1, 1], // 4
    [1, 1, 1, 1, 1, 1, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 1, 1, 1, 1], // 5   THESE ARE OUR X VALUES
    [1, 1, 1, 1, 1, 1, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 1, 1, 1, 1], // 6
    [1, 1, 1, 1, 1, 1, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 1, 1, 1, 1], // 7
    [1, 1, 1, 1, 1, 1, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 1, 1, 1, 1], // 8
    [1, 1, 1, 1, 1, 1, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 1, 1, 1, 1], // 9
    [1, 1, 1, 1, 1, 1, 1, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 1, 1, 1, 1, 1], // 10
    [1, 1, 1, 1, 1, 1, 1, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 1, 1, 1, 1, 1], // 11
    [1, 1, 1, 1, 1, 1, 1, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 1, 1, 1, 1, 1], // 12
    [1, 1, 1, 1, 1, 1, 1, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 1, 1, 1, 1, 1], // 13
    [1, 1, 1, 1, 1, 1, 1, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 1, 1, 1, 1, 1], // 14
    [1, 1, 1, 1, 1, 1, 1,12, 1, 1, 1, 1, 1, 1, 1, 0, 0, 0, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1]  // 15
  ],

  

  startTileX : 0,
  startTileY : 0
}

let level3 = {

  graphicMap: [
  //    THESE ARE OUR Y VALUES
  // 0  1  2  3  4  5  6  7  8  9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31
    [6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6], // 0
    [6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6], // 1
    [6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6], // 2
    [6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6], // 3
    [6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6], // 4
    [6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6], // 5   THESE ARE OUR X VALUES
    [6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6], // 6
    [6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6], // 7
    [6, 6, 6, 6, 6, 6, 6, 6, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6], // 8
    [6, 6, 6, 6, 6, 6, 6, 6, 3, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 3, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6], // 9
    [6, 6, 6, 6, 6, 6, 6, 6, 3, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 3, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6], // 10
    [6, 6, 6, 6, 6, 6, 6, 6, 3, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 3, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6], // 11
    [6, 6, 6, 6, 6, 6, 6, 6, 3, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 3, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6], // 12
    [6, 6, 6, 6, 6, 6, 6, 6, 3, 6, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6], // 13
    [6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6], // 14
    [6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6]  // 15
  ],

  tileRules: [
  //    THESE ARE OUR Y VALUES
  // 0  1  2  3  4  5  6  7  8  9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31
    [1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1], // 0
    [1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1], // 1
    [1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1], // 2
    [1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1], // 3
    [1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1], // 4
    [1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1], // 5   THESE ARE OUR X VALUES
    [1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1], // 6
    [1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1], // 7
    [1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1], // 8
    [1, 1, 1, 1, 1, 1, 1, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1], // 9
    [1, 1, 1, 1, 1, 1, 1, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1], // 10
    [1, 1, 1, 1, 1, 1, 1, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1], // 11
    [1, 1, 1, 1, 1, 1, 1, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1], // 12
    [1, 1, 1, 1, 1, 1, 1, 1, 1,15, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1], // 13
    [1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1], // 14
    [1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1]  // 15
  ],

  

  startTileX : 0,
  startTileY : 0
}

let level4 = {

  graphicMap: [
  //    THESE ARE OUR Y VALUES
  // 0  1  2  3  4  5  6  7  8  9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31
    [6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6], // 0
    [6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6], // 1
    [6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6], // 2
    [6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6], // 3
    [6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6], // 4
    [6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6], // 5   THESE ARE OUR X VALUES
    [6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 2, 2, 2, 2, 2, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6], // 6
    [6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 2, 4, 4, 4, 2, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6], // 7
    [6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 2, 4, 4, 4, 2, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6], // 8
    [6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 2, 4, 4, 4, 2, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6], // 9
    [6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 2, 2, 6, 2, 2, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6], // 10
    [6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6], // 11
    [6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6], // 12
    [6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6], // 13
    [6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6], // 14
    [6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6]  // 15
  ],

  tileRules: [
  //    THESE ARE OUR Y VALUES
  // 0  1  2  3  4  5  6  7  8  9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31
    [1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1], // 0
    [1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1], // 1
    [1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1], // 2
    [1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1], // 3
    [1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1], // 4
    [1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1], // 5   THESE ARE OUR X VALUES
    [1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1], // 6
    [1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0,81, 0, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1], // 7
    [1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0, 0, 0, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1], // 8
    [1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0, 0, 0, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1], // 9
    [1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,17, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1], // 10
    [1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1], // 11
    [1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1], // 12
    [1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1], // 13
    [1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1], // 14
    [1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1]  // 15
  ],

  

  startTileX : 0,
  startTileY : 0
}

let level5 = {

  graphicMap: [
  //    THESE ARE OUR Y VALUES
  // 0  1  2  3  4  5  6  7  8  9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31
    [6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6], // 0
    [6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6], // 1
    [6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6], // 2
    [6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6], // 3
    [6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6], // 4
    [6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6], // 5   THESE ARE OUR X VALUES
    [6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6], // 6
    [6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6], // 7
    [6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 3, 3, 3, 3, 3, 6, 6, 6, 6, 6, 6, 6], // 8
    [6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 3, 4, 4, 4, 3, 6, 6, 6, 6, 6, 6, 6], // 9
    [6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 3, 4, 4, 4, 3, 6, 6, 6, 6, 6, 6, 6], // 10
    [6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 3, 4, 4, 4, 3, 6, 6, 6, 6, 6, 6, 6], // 11
    [6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 3, 4, 4, 4, 3, 6, 6, 6, 6, 6, 6, 6], // 12
    [6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 3, 3, 3, 6, 3, 6, 6, 6, 6, 6, 6, 6], // 13
    [6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6], // 14
    [6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6]  // 15
  ],

  tileRules: [
  //    THESE ARE OUR Y VALUES
  // 0  1  2  3  4  5  6  7  8  9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31
    [1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1], // 0
    [1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1], // 1
    [1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1], // 2
    [1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1], // 3
    [1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1], // 4
    [1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1], // 5   THESE ARE OUR X VALUES
    [1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1], // 6
    [1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1], // 7
    [1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1], // 8
    [1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0, 0, 0, 1, 1, 1, 1, 1, 1, 1, 1], // 9
    [1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0, 0, 0, 1, 1, 1, 1, 1, 1, 1, 1], // 10
    [1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0, 0, 0, 1, 1, 1, 1, 1, 1, 1, 1], // 11
    [1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0, 0, 0, 1, 1, 1, 1, 1, 1, 1, 1], // 12
    [1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,19, 1, 1, 1, 1, 1, 1, 1, 1], // 13
    [1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1], // 14
    [1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1]  // 15
  ],

  

  startTileX : 0,
  startTileY : 0
}

let level6 = {

  graphicMap: [
  //    THESE ARE OUR Y VALUES
  // 0  1  2  3  4  5  6  7  8  9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31
    [6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6], // 0
    [6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6], // 1
    [6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 2, 2, 2, 2, 2, 6, 6, 6, 6, 6, 6, 6], // 2
    [6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 2, 4, 4, 4, 2, 6, 6, 6, 6, 6, 6, 6], // 3
    [6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 2, 4, 4, 4, 2, 6, 6, 6, 6, 6, 6, 6], // 4
    [6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 2, 4, 4, 4, 2, 6, 6, 6, 6, 6, 6, 6], // 5   THESE ARE OUR X VALUES
    [6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 2, 2, 6, 2, 2, 6, 6, 6, 6, 6, 6, 6], // 6
    [6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6], // 7
    [6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6], // 8
    [6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6], // 9
    [6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6], // 10
    [6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6], // 11
    [6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6], // 12
    [6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6], // 13
    [6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6], // 14
    [6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6]  // 15
  ],

  tileRules: [
  //    THESE ARE OUR Y VALUES
  // 0  1  2  3  4  5  6  7  8  9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31
    [1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1], // 0
    [1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1], // 1
    [1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1], // 2
    [1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0,82, 0, 1, 1, 1, 1, 1, 1, 1, 1], // 3
    [1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0, 0, 0, 1, 1, 1, 1, 1, 1, 1, 1], // 4
    [1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0, 0, 0, 1, 1, 1, 1, 1, 1, 1, 1], // 5   THESE ARE OUR X VALUES
    [1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,21, 1, 1, 1, 1, 1, 1, 1, 1, 1], // 6
    [1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1], // 7
    [1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1], // 8
    [1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1], // 9
    [1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1], // 10
    [1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1], // 11
    [1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1], // 12
    [1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1], // 13
    [1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1], // 14
    [1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1]  // 15
  ],

  

  startTileX : 0,
  startTileY : 0
}

let level7 = {

  graphicMap: [
  //    THESE ARE OUR Y VALUES
  // 0  1  2  3  4  5  6  7  8  9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31
    [6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6], // 0
    [6, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 6], // 1
    [6, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 6], // 2
    [6, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 6], // 3
    [6, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 6], // 4
    [6, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 6], // 5   THESE ARE OUR X VALUES
    [6, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 6], // 6
    [6, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 6], // 7
    [6, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 6], // 8
    [6, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 6], // 9
    [6, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 6], // 10
    [6, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 6], // 11
    [6, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 6], // 12
    [6, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 6], // 13
    [6, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 6], // 14
    [6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6]  // 15
  ],

  tileRules: [
  //    THESE ARE OUR Y VALUES
  // 0  1  2  3  4  5  6  7  8  9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31
    [1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1], // 0
    [1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1], // 1
    [1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1], // 2
    [1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1], // 3
    [1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1], // 4
    [1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1], // 5   THESE ARE OUR X VALUES
    [1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1], // 6
    [1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1], // 7
    [1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1], // 8
    [1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1], // 9
    [1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1], // 10
    [1, 0, 0, 0, 0, 0, 0, 0,23, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1], // 11
    [1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1], // 12
    [1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1], // 13
    [1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1], // 14
    [1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1]  // 15
  ],

  

  startTileX : 0,
  startTileY : 0
}

// level control variables
let levels = [level0, level1, level2, level3, level4, level5, level6, level7]
let currentLevel = 0
let graphicMap
let tileRules


class Tile { //creates class for a tile
  constructor(texture, tileX, tileY, tileSize, tileID) {
    this.texture = texture; //texture of tile in tileMap grid
    this.tileX = tileX; //x position of tile in tileMap grid
    this.tileY = tileY; //y position of tile in tileMap grid
    this.tileSize = tileSize; //size of tiles in pixels
    this.xPos = (this.tileX * this.tileSize) + (this.tileSize/2); //x pixel position of tile in canvas
    this.yPos = (this.tileY * this.tileSize) + (this.tileSize/2) + hudSize; //y pixel position of tile in canvas
    this.tileID = tileID; //identification of each individual tile
  }


  display() {
    noStroke() // no boarder on the images of tiles drawn
    image(this.texture, this.xPos, this.yPos, tileSize, tileSize) //draws tile 
  }


  debugGrid() { //used to display the x and y of the tiles in the tileMap scale (not default pixel scale), along with the tiles IDs

    let xPadding = 2 //pads text so it displays within the box (x axis)
    let yCoordinatePadding = 8 //pads coordinate text so it displays within the box (y axis) but above ID text
    let yIDPadding = 18 //pads ID text so it displays within the box (y axis) and below the coordinate text

    //All Text Settings
    strokeWeight(1)
    stroke("black")
    fill("yellow")

    //display X and Y coordinate Text
    textSize(8)
    text("X: " + this.tileX + ", Y: " + this.tileY, this.xPos +xPadding, this.yPos + yCoordinatePadding)

    //Display tileID text
    textSize(10)
    text("ID: " + this.tileID, this.xPos + xPadding, this.yPos + yIDPadding)

    //Create rect around tile
    noFill()
    stroke("yellow")
    rect(this.xPos, this.yPos, this.tileSize, this.tileSize)
  }

  displayMessage() { //adds a message to specified tiles

    let xPadding = 2 //pads text so it displays within the box (x axis)
    let yPadding = 40 //pads message so it displays withing the box and below the ID text

    // display message text
    strokeWeight(1)
    stroke("black")
    fill("white")
    textSize(10)
    text("Accessed!", this.xPos + xPadding, this.yPos + yPadding)
  }
}



class Player {
  constructor(currentSpriteGroup, startX, startY){
    this.currentSpriteGroup = currentSpriteGroup // groups of sprites. Each group containing the still and walking sprites for a single direction of movement.
    this.currentSprite = this.currentSpriteGroup[0] // start on 0 (standing still) in the group the player starts on
    this.startX = startX // x value for starting position. used for respawning 
    this.startY = startY // y value for starting position. used for respawning 
    this.posX = this.startX // sets starting x position when you first load the game
    this.posY = this.startY // sets starting y position when you first load the game
    this.directionState = 0 //used for working out things like direction of collision
    this.directionOfCollision = 4 // used to know what way the player cannot walk on collisons (4 is the state of no collision occouring)
    this.speed = 0.08 // player movement speed
    this.hitboxSize = 40 // slightly smaller than tile size so player can fit between two with a 1 tile wide gap without difficulty
    this.maxHealth = 50 // player's maximum health at astart of gameplay 
    this.currentHealth = this.maxHealth // starts on max health
    this.isMoving = false // is player moving
    this.leg = 0  // 0 is state for no legs moving, for standing still/not walking
    this.nextPosX = startX // keeps x value of where player is trying to move before actually moving them
    this.nextPosY = startY // keeps y value of where player is trying to move before actually moving them
    this.collided = false // is collision occuring
    this.attacking = false // is player attacking
    this.damagedRecently = false // has player been recently damaged
    this.alive = true
  }
  
  basicNPCs(NPCTileRulesVal,NPCName,dialogueType,tileY,tileX) {
    if (tileRules[tileY][tileX] == NPCTileRulesVal){
      NPCName.display(tileY,tileX)
      if ((this.nextPosX >= tileX*tileSize - (tileSize + (this.hitboxSize/2)) && this.nextPosX <= tileX*tileSize + (tileSize*2 + (this.hitboxSize/2))) && (this.nextPosY >= tileY*tileSize - (tileSize + (this.hitboxSize/2)) + (hudSize) && this.nextPosY <= tileY*tileSize + (tileSize*2 + (this.hitboxSize/2)) + (hudSize))){ // if player is close enough to npc 
        NPCName.speak(dialogueType,tileY,tileX)
      }
      else{
        NPCName.resetSpeech()
      }

    }
  }

  levelChangeCheck(tileRuleValue, levelChangeTo, newPlayerTileX, newPlayerTileY, RespawnLevel, RespawnX, RespawnY, tileY, tileX) {
    if (tileRules[tileY][tileX] == tileRuleValue){ // checks if tile is a level changer 
      if ((this.nextPosX >= tileX*tileSize - (this.hitboxSize/2) && this.nextPosX <= tileX*tileSize + (tileSize + (this.hitboxSize/2))) && (this.nextPosY >= tileY*tileSize - (this.hitboxSize/2) + (hudSize) && this.nextPosY <= tileY*tileSize + (tileSize + (this.hitboxSize/2)) + (hudSize))){ // if player is close enough to tile to have entered it
        //where the player will spawn if entering level0 from a 10 tile rule
        levels[levelChangeTo].startTileX = newPlayerTileX
        levels[levelChangeTo].startTileY = newPlayerTileY
        currentLevel = levelChangeTo
        //changes where player respawns on death vv
        spawnTileX = RespawnX
        spawnTileY = RespawnY
        spawnLevel = RespawnLevel
        loadLevel()
      }
    }
  }

  move() {                                                               
    if (((keyIsDown(87))||(keyIsDown(65))||(keyIsDown(83))||(keyIsDown(68))) && (this.attacking == false) && (this.alive == true)){ // if player is moving and attacking is false
      this.isMoving = true // set moving to true
    }
    else{
      this.isMoving = false // set moving to false
      this.leg = 0 // 0 is for standing still/not walking
      counter = 0 // for anything that must occur after a certain amount of time after a conditin is met (switching legs when walking condition is met)
    }
    if (this.isMoving == true){
      if (keyIsDown(87) == true){ //W UP
        this.directionState = up 
        this.currentSpriteGroup = sprites.knight_up
        this.nextPosY = this.posY - this.speed 
      }
      else if (keyIsDown(65) == true){ //A LEFT
        this.directionState = left 
        this.currentSpriteGroup = sprites.knight_left
        this.nextPosX = this.posX - this.speed
      }
      else if (keyIsDown(83) == true){ //S DOWN
        this.directionState = down
        this.currentSpriteGroup = sprites.knight_down
        this.nextPosY = this.posY + this.speed
      }
      else if (keyIsDown(68) == true){ //D RIGHT
        this.directionState = right
        this.currentSpriteGroup = sprites.knight_right
        this.nextPosX = this.posX + this.speed
      }
    }

    
    for (let tileX = 0; tileX < tilesX; tileX++) { // loops the checks of tiles for things like collisions and level transitions, for how many tiles there are horizontally
      for (let tileY = 0; tileY < tilesY; tileY++) { // loops the checks of tiles for things like collisions and level transitions, for how many tiles there are vertically
        
// Checking for SPAWN NPC tile rules vv

//Healer
        if (tileRules[tileY][tileX] == 81){
          healerNPC.display(tileY,tileX)
          if ((this.nextPosX >= tileX*tileSize - (tileSize + (this.hitboxSize/2)) && this.nextPosX <= tileX*tileSize + (tileSize*2 + (this.hitboxSize/2))) && (this.nextPosY >= tileY*tileSize - (tileSize + (this.hitboxSize/2)) + (hudSize) && this.nextPosY <= tileY*tileSize + (tileSize*2 + (this.hitboxSize/2)) + (hudSize))){ // if player is close enough to npc 
            healerNPC.speak(healerDialogue,tileY,tileX)
            player1.currentHealth = player1.maxHealth
          }
          else{
            healerNPC.resetSpeech()
            healerDialogue = 1
          }
          
        }
//Questgiver
        this.basicNPCs(80,questgiverNPC,0,tileY,tileX)
//Back Right house resident
        this.basicNPCs(82,residentNPC,3,tileY,tileX)
//Guards
        this.basicNPCs(83,guard1NPC,4,tileY,tileX)
        this.basicNPCs(84,guard2NPC,4,tileY,tileX)
//Kid
        this.basicNPCs(85,kid1NPC,5,tileY,tileX)

// Checking for TILE TOPPER tile rules vv (stuff on top of tiles. Like ladder, boat, or household objects/furniture)
        if (tileRules[tileY][tileX] == 22){
          image(ladderDown, tileX*tileSize + (tileSize/2), (tileY*tileSize) + (tileSize/2) + hudSize, tileSize, tileSize)
        }
        if (tileRules[tileY][tileX] == 23){
          image(ladderUp, tileX*tileSize + (tileSize/2), (tileY*tileSize) + (tileSize/2) + hudSize, tileSize, tileSize)
        }
//Checking for LEVEL CHANGE tile rules vv

//tileRuleValue, levelChangeTo, newPlayerTileX, newPlayerTileY, RespawnLevel, RespawnX, RespawnY, tileY, tileX
        this.levelChangeCheck(10, 0, 16, 1, spawnLevel, spawnTileX, spawnTileY, tileY, tileX)// spawnLevel spawnTileX and spawnTileY being kept same means player hasn't entered a place that changes where they will respawn.
        this.levelChangeCheck(11, 1, 16, 14, 4, 12, 8, tileY, tileX) // spawnLevel spawnTileX and spawnTileY being changed occurs when player enters a place that changes where they will respawn upon death. (usually entering a village for example)
        this.levelChangeCheck(12, 0, 7, 1, spawnLevel, spawnTileX, spawnTileY, tileY, tileX)
        this.levelChangeCheck(13, 2, 7, 14, spawnLevel, spawnTileX, spawnTileY, tileY, tileX) 
        this.levelChangeCheck(14, 3, 9, 12, spawnLevel, spawnTileX, spawnTileY, tileY, tileX)
        this.levelChangeCheck(15, 1, 9, 2, spawnLevel, spawnTileX, spawnTileY, tileY, tileX)
        this.levelChangeCheck(16, 4, 12, 9, spawnLevel, spawnTileX, spawnTileY, tileY, tileX)
        this.levelChangeCheck(17, 1, 12, 11, spawnLevel, spawnTileX, spawnTileY, tileY, tileX)
        this.levelChangeCheck(18, 5, 23, 12, spawnLevel, spawnTileX, spawnTileY, tileY, tileX)
        this.levelChangeCheck(19, 1, 23, 2, spawnLevel, spawnTileX, spawnTileY, tileY, tileX)
        this.levelChangeCheck(20, 6, 22, 5, spawnLevel, spawnTileX, spawnTileY, tileY, tileX)
        this.levelChangeCheck(21, 1, 22, 6, spawnLevel, spawnTileX, spawnTileY, tileY, tileX)
        this.levelChangeCheck(22, 7, 8, 12, spawnLevel, spawnTileX, spawnTileY, tileY, tileX)
        this.levelChangeCheck(23, 0, 8, 10, spawnLevel, spawnTileX, spawnTileY, tileY, tileX)

//checking tile collision vv

        tileIsCollidable = false // variable set to false by default before checking the next tile

        for (let i = 0; i < collidableTilesList.length; i++){
          if (tileRules[tileY][tileX] == collidableTilesList[i]){ // checks if this tile is collidable
            tileIsCollidable = true // variable set to true if value for tile is collidable
          }
      }

        if (tileIsCollidable == true){ // if tile is labelled to have collision
          collidableTiles += 1 // count of how many collidable tiles there are
          if ((this.nextPosX >= tileX*tileSize - (this.hitboxSize/2) && this.nextPosX <= tileX*tileSize + (tileSize + (this.hitboxSize/2))) && (this.nextPosY >= tileY*tileSize - (this.hitboxSize/2) + (hudSize) && this.nextPosY <= tileY*tileSize + (tileSize + (this.hitboxSize/2)) + (hudSize)) && (this.collided == false)){ // if player is close enough to tile to have collided with it (and a collision has not yet occured with another tile)
            this.directionOfCollision = this.directionState // (direction of the collided tile compared to the player). direction of collision is set to the direction the player is moving at the time the player collides with the tile
            this.collided = true // collision is occuring
            //pushes player back a little when they collide with a tile. This was implemented to fix a bug that allowed the player to enter other collidable tiles if first colliding with another tile perpendicular to it
            // vv
            if (this.directionState == up){
              this.nextPosY = this.posY + this.speed
            }
            if (this.directionState == left){
              this.nextPosX = this.posX + this.speed
            }
            if (this.directionState == down){
              this.nextPosY = this.posY - this.speed
            }
            if (this.directionState == right){
              this.nextPosX = this.posX - this.speed
            }
          }
          if (!((this.nextPosX >= tileX*tileSize && this.nextPosX <= tileX*tileSize + (tileSize)) && (this.nextPosY >= tileY*tileSize + (hudSize) && this.nextPosY <= tileY*tileSize + (tileSize) + (hudSize)))){ // if player is not close enough to tile to have collided with it
            collidableTiles_NotCollidedWith += 1 // add one to the count of how many collidable tiles there are that the player hasn't collided with
          }
        }
      }
    }
    if (collidableTiles_NotCollidedWith == collidableTiles){ // if none of the collidable tiles get collided with by the player:
      this.collided = false // collision is not occuring
      this.directionOfCollision = 4 // 4 is the state of no collision occouring in any direction, allowing player to walk in all 4 directions
    }
    collidableTiles = 0 // resets for next check
    collidableTiles_NotCollidedWith = 0 // resets for next check
    if (this.directionOfCollision != this.directionState){ // if attempting to walk in a direction that isn't the direction the collision occured 
      if(((keyIsDown(65))||(keyIsDown(68))||(keyIsDown(87))||(keyIsDown(83))) && (this.attacking == false)){ // if walking key is pressed (wasd) , and attacking is not happening
        this.posX = this.nextPosX // move in x direction
        this.posY = this.nextPosY // move in y direction
      }
    }


    if (this.isMoving == true){// if player is moving
      counter += 1 // n increments every loop
      if (this.leg == 0){ //if walking has just started:
        this.leg = 1  // start walking with left leg up
      }//       n vv
      else if (counter == 600){ //swaps legs every n loops, while isMoving stays true
        counter = 0 //starts n at 0
        if (this.leg == 1){
          this.leg = 2 // right leg
        }
        else{
          this.leg = 1 // left leg
        }
      }
      
    }

    this.currentSprite = this.currentSpriteGroup[this.leg] //updates current player sprite, depending on direction looking, and if moving or stationary
  }

  attack (){
    if (keyIsDown(32)){
      this.attacking = true

      if (this.directionState == up){
        image(sprites.sword[this.directionState],this.posX,this.posY - attackRange,tileSize/2,tileSize)

        //playerWeaponHitbox = (!(enemyX - (enemySize/2) >= this.posX + (this.hitboxSize/2) && enemyX + (enemySize/2) <= this.posX - (this.hitboxSize/2) && enemyY + (enemySize/2) <= this.posY - (this.hitboxSize + (this.hitboxSize/2)) && enemyY - (enemySize/2) >= this.posY + (-this.hitboxSize + (this.hitboxSize/2))))
      }
      if (this.directionState == left){
        image(sprites.sword[this.directionState],this.posX - attackRange,this.posY,tileSize,tileSize/2)

        //
      }
      if (this.directionState == down){
        image(sprites.sword[this.directionState],this.posX,this.posY + attackRange,tileSize/2,tileSize)

        //
      }
      if (this.directionState == right){
        image(sprites.sword[this.directionState],this.posX + attackRange,this.posY,tileSize,tileSize/2)

        //
      }
      
      //for (number of enemies in enemy list){
        //if ((enemy 1,2, etc) is within "playerWeaponHitbox"){
          //enemyCurrentHealth += - playerWeaponDamage
        //}
      //}
    }
    else {
      this.attacking = false
    }
  }

  hud(){
    if (this.alive == true){
      fill(50,100,50)
      noStroke()
      rect(0,0,1600,hudSize)
    }
    this.healthbar()
  }
  
  healthbar(){
    //healthbar outline
    noFill()
    stroke(0)
    rect(20,50,this.maxHealth,20) // healthbar outline
    fill(200,0,0)
    noStroke()
    textSize(30)//scales text size
    text(this.currentHealth,50,40)//text display of health
    rect(20,50,this.maxHealth/(this.maxHealth/this.currentHealth),20) // healthbar (decreasing part when player is damaged)
  }            //bar length                        //bar thickness

  damageCheck() {
    // player is hit    and   player has not been hit too recently (invincibility frames gone)
    if ((mouseIsPressed) && (this.damagedRecently == false)){ // if [player is hit by enemy] and player has not been recently damaged
      this.currentHealth += -25 // take damage // n will be the damage an enemy does
      this.damagedRecently = true // player has been recently damaged
    }
    if (this.damagedRecently == true){ // if player has been recently damaged
      counter1 += 1 // count increments
    }
    if (counter1 == 3000){ // n is time being invincible after being hit
      this.damagedRecently = false // player no longer recently damaged (able to be damaged again)
      counter1 = 0 // reset invincibility counter
    }

    if (this.currentHealth <= 0){ // if player dies
      this.alive = false
      if (counter2 >= 300){ // once screen is 100% black // 255 is the max for alpha but a slight delay staying on the black screen as the counter continues to go to the higher number before respawning looks nice
        this.currentHealth = this.maxHealth // sets current health to max
        this.directionState = down
        this.currentSpriteGroup = sprites.knight_down
        this.alive = true
        currentLevel = spawnLevel
        levels[currentLevel].startTileX = spawnTileX
        levels[currentLevel].startTileY = spawnTileY
        loadLevel()

        healerDialogue = 2
        counter2 = 0
      }
    }
  }

  deathScreen(){
    if (this.alive == false){
      fill(0,0,0,counter2)
      rect(0,hudSize,1600,800)
      counter2 += 0.05
    }
  }

  display (){
    //player sprite          //player x //player y  //width  //height
    image(this.currentSprite,this.posX,this.posY,tileSize,tileSize) //draws player sprite
  }

}

class Enemy {
  constructor(enemySprite, enemyHp) {
    this.enemySprite = enemySprite;
    this.enemyHp = enemyHp;
  }

  display(tileY_enemy,tileX_enemy) {
    // Displays the sprite
    image(this.enemySprite, this.tileX_enemy, this.tileY_enemy, tileSize, tileSize);

    // Displays HP above the slimes head
    fill("black");
    textSize(15);
    text(
      this.enemyHp,
      tileX_enemy*tileSize + (tileSize/2),
      (tileY_enemy*tileSize) + hudSize - (tileSize/4) // Moves HP above the slime
    );
  }
}



class Npc {
  constructor(NPCSprite, dialogueChangeSpeed) {
    this.NPCSprite = NPCSprite;
    this.dialogueChangeSpeed = 1000 * dialogueChangeSpeed // speed at which npc speech is cycled through, *1000 to make dialogueChangeSpeed be in seconds
    this.counter3 = 0 // used for npc dialogue rotation. Needed to change this to be in the npc constructor, so two NPCs on the same map still had individual counters.
    this.currentDialogueIndex = 0; // Tracks which dialogue line to display
  }

  display(tileY_NPC,tileX_NPC) {
    // Displays the NPC sprite
    image(this.NPCSprite, tileX_NPC*tileSize + (tileSize/2), (tileY_NPC*tileSize) + (tileSize/2) + hudSize, tileSize, tileSize);
  }

  speak(dialogueType,tileY_NPC,tileX_NPC) {
    if (this.counter3 < this.dialogueChangeSpeed) {
        // Display current dialogue
        stroke(255)
        fill(0)
        textSize(15);
        text(
          dialogue[dialogueType][this.currentDialogueIndex],
          tileX_NPC*tileSize + (tileSize/2),
          (tileY_NPC*tileSize) + hudSize - (tileSize/4) // sits above npc
        );

    } 
    else {
      // Move to next dialogue and reset timer
      this.currentDialogueIndex++;
      if (this.currentDialogueIndex >= dialogue[dialogueType].length) {
        this.currentDialogueIndex = 0; // Loop back to the first dialogue
      }
      this.counter3 = 0; // Reset timer
    }
    this.counter3++
  }

  resetSpeech(){
    this.currentDialogueIndex = 0; // Reset to the first dialogue
    this.counter3 = 0; // Reset timer
  }
}



function preload() { 
  //Tiles
  textures[0] = loadImage('sprites/tile_grass.png') 
  textures[1] = loadImage('sprites/tile_water.png')
  textures[2] = loadImage('sprites/tile_wood.png')
  textures[3] = loadImage('sprites/tile_stone_wall.png')
  textures[4] = loadImage('sprites/tile_wood_floor.png')
  textures[5] = loadImage('sprites/tile_stone_floor.png')
  textures[6] = loadImage('sprites/tile_void.png')

  //Player
  sprites = { //groups of sprites. 
  // Each group here containing the still and walking sprites for a single direction of movement.
    knight_up: [loadImage('sprites/knight_up_still.png'),loadImage('sprites/knight_up_leftlegwalk.png'),loadImage('sprites/knight_up_rightlegwalk.png')],
    knight_left: [loadImage('sprites/knight_left_still.png'),loadImage('sprites/knight_left_leftlegwalk.png'),loadImage('sprites/knight_left_rightlegwalk.png')],
    knight_down: [loadImage('sprites/knight_down_still.png'),loadImage('sprites/knight_down_leftlegwalk.png'),loadImage('sprites/knight_down_rightlegwalk.png')],
    knight_right: [loadImage('sprites/knight_right_still.png'),loadImage('sprites/knight_right_leftlegwalk.png'),loadImage('sprites/knight_right_rightlegwalk.png')],

    // group of sprites. Each group containing the sword sprite for a single direction of movement.
    sword: [loadImage('sprites/sword_up_middle.png'),loadImage('sprites/sword_left_middle.png'),loadImage('sprites/sword_down_middle.png'),loadImage('sprites/sword_right_middle.png')]
  }

  //Objects
  ladderDown = loadImage("sprites/tile_topper_ladderdown.png")
  ladderUp = loadImage("sprites/tile_topper_ladderup.png")

  //Enemies
  redSlimeSprite = loadImage("sprites/redSlime.png")

  //NPCs
  questgiverNPCSprite = loadImage("sprites/NPC_Questgiver.png")
  guard1NPCSprite = loadImage("sprites/NPC_Guard1.png")
  guard2NPCSprite = loadImage("sprites/NPC_Guard2.png")
  healerNPCSprite = loadImage("sprites/NPC_Healer.png")
  kid1NPCSprite = loadImage("sprites/NPC_Kid1.png")
  residentNPCSprite = loadImage("sprites/NPC_Resident.png")
}



function setup() {
  createCanvas(1600,800 + hudSize)
  imageMode(CENTER)
  rectMode(CORNER)
  textAlign(CENTER,CENTER)

  player1 = new Player(sprites.knight_down, (spawnTileX*tileSize) + tileSize/2, (spawnTileY*tileSize) + tileSize/2 + hudSize) // instance of Player class

  redSlime = new Enemy(redSlimeSprite, enemyHp);
                                      // dialogue array // speed at which npc speech is cycled through, *1000 to make dialogueChangeSpeed be in seconds
  questgiverNPC = new Npc(questgiverNPCSprite, 5); // basic civilian
  healerNPC = new Npc(healerNPCSprite, 6); // healer, in a robe
  guard1NPC = new Npc(guard1NPCSprite, 5); // guard, in a cloak
  guard2NPC = new Npc(guard2NPCSprite, 5); // guard, in a cloak
  kid1NPC = new Npc(kid1NPCSprite, 5) // kid, in a cloak, dressed up like the guards
  residentNPC = new Npc(residentNPCSprite, 5) // basic civillian

  loadLevel()
}



function loadLevel() {

  graphicMap = levels[currentLevel].graphicMap
  tileRules = levels[currentLevel].tileRules

  player1.posX = ((levels[currentLevel].startTileX) * tileSize) + tileSize/2
  player1.posY = ((levels[currentLevel].startTileY) * tileSize) + hudSize + tileSize/2
  player1.nextPosX = player1.posX
  player1.nextPosY = player1.posY

  let tileID = 0 //identification of each individual tile, starting at 0
  for (let tileX = 0; tileX < tilesX; tileX++) { // loops the tile creation for how many tiles there are supposed to be horizontally in the tile map
    tileMap[tileX] = []
    for (let tileY = 0; tileY < tilesY; tileY++) { // loops the tile creation for how many tiles there are supposed to be vertically in the tile map
      let texture = graphicMap[tileY][tileX]
      tileMap[tileX][tileY] = new Tile(textures[texture], tileX, tileY, tileSize, tileID) //creates a tile object for every 50 pixels down and every 50 pixels right
      tileID++
    }
  }
}



function draw() {
  background(100) // 
  for (let tileX = 0; tileX < tilesX; tileX++) { // loops the tile display for how many tiles there are horizontally
    for (let tileY = 0; tileY < tilesY; tileY++) { // loops the tile display for how many tiles there are vertically
      tileMap[tileX][tileY].display() // display tile
      //tileMap[tileX][tileY].debugGrid() //displays the x and y of the tile in the tileMap scale (not default pixel scale), along with the tile ID
    }
    
    player1.move()
    player1.attack()
    player1.display()
    player1.hud()
    player1.damageCheck()
    player1.deathScreen()

  }

  //tileMap[5][6].displayMessage()//adding a message to specified tiles
}







